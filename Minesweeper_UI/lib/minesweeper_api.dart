// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for the MinesweeperCore C++ library.
class MinesweeperApi {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
  _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  MinesweeperApi(ffi.DynamicLibrary dynamicLibrary)
    : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  MinesweeperApi.fromLookup(
    ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) lookup,
  ) : _lookup = lookup;

  ffi.Pointer<Game> create_game(int width, int height, int mines) {
    return _create_game(width, height, mines);
  }

  late final _create_gamePtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<Game> Function(ffi.Int, ffi.Int, ffi.Int)
        >
      >('create_game');
  late final _create_game = _create_gamePtr
      .asFunction<ffi.Pointer<Game> Function(int, int, int)>();

  void destroy_game(ffi.Pointer<Game> game_instance) {
    return _destroy_game(game_instance);
  }

  late final _destroy_gamePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<Game>)>>(
        'destroy_game',
      );
  late final _destroy_game = _destroy_gamePtr
      .asFunction<void Function(ffi.Pointer<Game>)>();

  void reveal_cell(ffi.Pointer<Game> game_instance, int x, int y) {
    return _reveal_cell(game_instance, x, y);
  }

  late final _reveal_cellPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<Game>, ffi.Int, ffi.Int)
        >
      >('reveal_cell');
  late final _reveal_cell = _reveal_cellPtr
      .asFunction<void Function(ffi.Pointer<Game>, int, int)>();

  void flag_cell(ffi.Pointer<Game> game_instance, int x, int y) {
    return _flag_cell(game_instance, x, y);
  }

  late final _flag_cellPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<Game>, ffi.Int, ffi.Int)
        >
      >('flag_cell');
  late final _flag_cell = _flag_cellPtr
      .asFunction<void Function(ffi.Pointer<Game>, int, int)>();

  int is_game_over(ffi.Pointer<Game> game_instance) {
    return _is_game_over(game_instance);
  }

  late final _is_game_overPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<Game>)>>(
        'is_game_over',
      );
  late final _is_game_over = _is_game_overPtr
      .asFunction<int Function(ffi.Pointer<Game>)>();

  int is_game_win(ffi.Pointer<Game> game_instance) {
    return _is_game_win(game_instance);
  }

  late final _is_game_winPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<Game>)>>(
        'is_game_win',
      );
  late final _is_game_win = _is_game_winPtr
      .asFunction<int Function(ffi.Pointer<Game>)>();

  void get_board_state(
    ffi.Pointer<Game> game_instance,
    ffi.Pointer<simple_block> state_array,
  ) {
    return _get_board_state(game_instance, state_array);
  }

  late final _get_board_statePtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<Game>, ffi.Pointer<simple_block>)
        >
      >('get_board_state');
  late final _get_board_state = _get_board_statePtr
      .asFunction<
        void Function(ffi.Pointer<Game>, ffi.Pointer<simple_block>)
      >();
}

final class simple_block extends ffi.Struct {
  @ffi.Int()
  external int mine;

  @ffi.Int()
  external int look;

  @ffi.Int()
  external int flag;

  @ffi.Int()
  external int neighbor_mines;
}

final class Game extends ffi.Opaque {}
